% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_one_to_one_cw.R
\name{get_one_to_one_cw}
\alias{get_one_to_one_cw}
\title{Generate One-to-One Correspondence Weights between Spatial Datasets}
\usage{
get_one_to_one_cw(dt_from, dt_to, funs = list(sf::st_covered_by))
}
\arguments{
\item{dt_from}{A \code{data.table} containing \code{sfc_MULTIPOLYGON} geometries with columns \code{from_geoid} and \code{geometry}.}

\item{dt_to}{A \code{data.table} containing \code{sfc_MULTIPOLYGON} geometries with columns \code{to_geoid} and \code{geometry}.}

\item{funs}{A list of spatial predicate functions (default is \code{list(st_covered_by)}) used to match geometries between \code{dt_from} and \code{dt_to}.}
}
\value{
A \code{data.table} with columns:
\itemize{
\item \code{from_geoid}: Identifier from \code{dt_from}.
\item \code{to_geoid}: Identifier from \code{dt_to}.
\item \code{afact}: Assignment factor, set to 1 for all matches.
}
}
\description{
This function creates a one-to-one correspondence table (crosswalk) between geometries in two spatial datasets (\code{dt_from} and \code{dt_to}). The function uses specified spatial matching functions to determine which geometries in \code{dt_from} correspond to geometries in \code{dt_to}.
}
\details{
The function checks that \code{dt_from} and \code{dt_to} are valid \code{data.table} objects with \code{sfc_MULTIPOLYGON} geometries and columns named \code{from_geoid} and \code{to_geoid}, respectively. It then applies the spatial functions specified in \code{funs} to establish one-to-one matches between the geometries in \code{dt_from} and \code{dt_to}.

For each spatial predicate in \code{funs}, if multiple geometries in \code{dt_from} correspond to a single geometry in \code{dt_to}, the function will stop with an error. Only unique matches (one-to-one) are accepted.
}
\examples{
\dontrun{
library(tigris); library(sf); library(data.table); library(magrittr)

options(tigris_use_cache = TRUE)

# get_one_to_one_cw() allocates all CT counties to CT state

ct_cnty22_sf <- tigris::counties(state = "CT", year = 2022) |>
 st_transform(crs = 5070) |>
 as.data.table() |>
 _[, .(geoid = GEOID, geometry)] |>
 sf::st_as_sf()
ct_st <- geolinkr::us_states_sf
ct_st <- ct_st[ct_st$statefp == "09", ]

covered_by_check <- sf::st_covered_by(ct_cnty22_sf, ct_st) \%>\%
  as.data.frame \%>\% as.data.table

stopifnot(nrow(covered_by_check) == nrow(ct_cnty22_sf))

dt_ct_cnty22 <- ct_cnty22_sf \%>\%
  as.data.table \%>\%
  .[, .(from_geoid = geoid, geometry)]

dt_ct_st <- ct_st \%>\%
  as.data.table \%>\%
  .[, .(to_geoid = statefp, geometry)]

cw <- get_one_to_one_cw(dt_from = dt_ct_cnty22,
                        dt_to = dt_ct_st)
print(cw)

stopifnot(nrow(cw) == nrow(ct_cnty22_sf))
stopifnot(sort(cw$from_geoid) == sort(ct_cnty22_sf$geoid))
stopifnot(cw[, unique(to_geoid)] == "09")
stopifnot(cw[, sum(afact)] == nrow(ct_cnty22_sf))
}
}
